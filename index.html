<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>T·ªè t√¨nh c·ª±c chill</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      background-color: #ffe6e6;
      text-align: center;
      padding-top: 100px;
      overflow: hidden;
    }

    h1 {
      font-size: 2em;
      color: #ff4d4d;
    }

    .buttons {
      margin-top: 30px;
      position: relative;
      width: 400px;
      height: 200px;
      margin: 0 auto;
      border: 2px dashed #ffb3b3;
      border-radius: 15px;
      background: #fff0f0;
      touch-action: none;
    }

    button {
      font-size: 1.2em;
      padding: 10px 20px;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.3s ease;
      position: absolute;
    }

    #yesBtn {
      background-color: #4CAF50;
      color: white;
      left: 30px;
      top: 80px;
      z-index: 1;
    }

    #noBtn {
      background-color: #f44336;
      color: white;
      left: 250px;
      top: 80px;
      z-index: 2;
      max-width: 100px;
      white-space: nowrap;
    }

    canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
    }
  </style>
</head>
<body>

  <script>
    // C·∫£nh b√°o n·∫øu truy c·∫≠p b·∫±ng ƒëi·ªán tho·∫°i
    if (/Mobi|Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {
      document.body.innerHTML = `
        <div style="text-align: center; padding: 50px; font-family: Arial, sans-serif;">
          <h2>Trang n√†y ch·ªâ h·ªó tr·ª£ tr√™n m√°y t√≠nh üíª</h2>
          <p>Vui l√≤ng m·ªü b·∫±ng m√°y t√≠nh ƒë·ªÉ c√≥ tr·∫£i nghi·ªám ƒë·∫ßy ƒë·ªß v√† vui v·∫ª nh√©!</p>
        </div>
      `;
      throw new Error("Thi·∫øt b·ªã kh√¥ng ƒë∆∞·ª£c h·ªó tr·ª£");
    }
  </script>

  <h1>L√†m ng∆∞·ªùi y√™u anh nh√©? üíñ</h1>

  <div class="buttons">
    <button id="yesBtn">Yes</button>
    <button id="noBtn">No</button>
  </div>

  <script>
    const noBtn = document.getElementById('noBtn');
    const yesBtn = document.getElementById('yesBtn');
    const buttonsDiv = document.querySelector('.buttons');

    let posX = 250;
    let posY = 80;

    function moveButton(x, y) {
      const rect = noBtn.getBoundingClientRect();
      const yesRect = yesBtn.getBoundingClientRect();
      const containerRect = buttonsDiv.getBoundingClientRect();

      const distanceX = x - (rect.left + rect.width / 2);
      const distanceY = y - (rect.top + rect.height / 2);
      const distance = Math.sqrt(distanceX * distanceX + distanceY * distanceY);

      if (distance < 100) {
        const moveX = (distanceX / distance) * 30;
        const moveY = (distanceY / distance) * 30;

        posX += moveX;
        posY += moveY;

        const maxX = buttonsDiv.clientWidth - noBtn.offsetWidth;
        const maxY = buttonsDiv.clientHeight - noBtn.offsetHeight;
        posX = Math.max(0, Math.min(maxX, posX));
        posY = Math.max(0, Math.min(maxY, posY));

        if (
          posX + noBtn.offsetWidth > yesBtn.offsetLeft - 10 &&
          posX < yesBtn.offsetLeft + yesBtn.offsetWidth + 10 &&
          posY + noBtn.offsetHeight > yesBtn.offsetTop - 10 &&
          posY < yesBtn.offsetTop + yesBtn.offsetHeight + 10
        ) {
          posX = Math.random() * maxX;
          posY = Math.random() * maxY;
        }

        noBtn.style.left = posX + "px";
        noBtn.style.top = posY + "px";
      }
    }

    document.addEventListener('mousemove', (e) => {
      moveButton(e.clientX, e.clientY);
    });

    document.addEventListener('touchmove', (e) => {
      const touch = e.touches[0];
      moveButton(touch.clientX, touch.clientY);
    });

    noBtn.addEventListener('click', () => {
      alert("Th√¥i m√†, b·∫•m Yes ƒëi m√† üò≥üíò");
    });

    yesBtn.addEventListener('click', () => {
      document.body.innerHTML = `
        <canvas id="canvas"></canvas>
        <div style="position: absolute; top: 20%; left: 50%; transform: translateX(-50%); text-align: center; z-index: 1;">
          <img src="cute.jfif" alt="Cute" style="max-width: 300px; border-radius: 20px; box-shadow: 0 0 20px #f99;" />
          <h1 style="color: white; text-shadow: 2px 2px 4px #f00; margin-top: 20px;">
            Y√™u anh nhi·ªÅu nhi·ªÅu nh√©eeee üíòüíòüíò
          </h1>
          <button onclick="window.location.href='tan_gai.mp4'" style="margin-top: 20px; padding: 10px 20px; font-size: 16px; background-color: pink; border: none; border-radius: 10px; cursor: pointer;">
            Xem video n√® üé•
          </button>
        </div>
      `;

      const canvas = document.getElementById('canvas');
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      const ctx = canvas.getContext('2d');

      let range = n => Array.from(Array(n).keys());

      class Vector {
        constructor(x = 0, y = 0) { this.x = x; this.y = y; }
        add(v) { return new Vector(this.x + v.x, this.y + v.y); }
        subtract(v) { return new Vector(this.x - v.x, this.y - v.y); }
        scale(s = 1) { return new Vector(this.x * s, this.y * s); }
      }

      class Point {
        constructor({ position, color = '#f00', size = 3 }) {
          this.position = position;
          this.color = color;
          this.size = size;
        }
        render(ctx) {
          ctx.beginPath();
          ctx.fillStyle = this.color;
          ctx.arc(this.position.x, this.position.y, this.size, 0, 2 * Math.PI);
          ctx.fill();
          ctx.closePath();
        }
      }

      class SpringPoint extends Point {
        constructor({ target, elasticity = 0.1, damping = 0.1, color, size }) {
          super({ position: target, color, size });
          this.velocity = new Vector();
          this.target = target;
          this.elasticity = elasticity;
          this.damping = damping;
        }
        update() {
          const force = this.target.subtract(this.position).scale(this.elasticity);
          this.velocity = this.velocity.add(force).scale(1 - this.damping);
          this.position = this.position.add(this.velocity);
        }
      }

      class SpringTrail extends SpringPoint {
        constructor(config) {
          super(config);
          this.trail = range(config.trailSize || 10).map(i => {
            return new SpringPoint({
              target: this.position,
              elasticity: 1 / (i * 8 + 1),
              damping: 0.1 + (i * 0.01),
              color: config.color,
              size: config.size
            });
          });
        }
        update() {
          super.update();
          this.trail.forEach(p => {
            p.target = this.position;
            p.update();
          });
        }
        render(ctx) {
          super.render(ctx);
          this.trail.forEach(p => p.render(ctx));
        }
      }

      const targets = [];
      const trails = [];
      const total = 60;
      const origin = new Vector(canvas.width / 2, canvas.height / 2);
      const mouse = new Vector(origin.x, origin.y);

      document.addEventListener('mousemove', (e) => {
        mouse.x = e.clientX;
        mouse.y = e.clientY;
      });

      function polar(t, time) {
        t += Math.sin(time / 100);
        const x = 16 * Math.sin(t) ** 3;
        const y = 13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t);
        const scale = (Math.sin(time / 10) + 3) * 4;
        return new Vector(x * scale, -y * scale)
          .add(origin.add(mouse.subtract(origin).scale(0.5)));
      }

      for (let i = 0; i < total; i++) {
        const target = new Vector(Math.random() * canvas.width, Math.random() * canvas.height);
        targets.push(target);
        trails.push(new SpringTrail({ target, color: "rgba(230, 10, 40, 0.8)", size: 1.3, trailSize: 10 }));
      }

      let time = 0;
      function animate() {
        time++;
        ctx.fillStyle = "rgba(20,20,20,0.2)";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        for (let i = 0; i < total; i++) {
          const angle = i / total * Math.PI * 2;
          const pos = polar(angle, time);
          targets[i].x = pos.x;
          targets[i].y = pos.y;
        }

        trails.forEach(t => {
          t.update();
          t.render(ctx);
        });

        requestAnimationFrame(animate);
      }
      animate();
    });
  </script>

</body>
</html>
